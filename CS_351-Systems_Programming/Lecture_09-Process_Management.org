#+TITLE: Lecture 09: Process Management
#+AUTHOR: Karl Hallsby
#+DATE: September 23, 2020

* Making Processes, ~fork~
#+BEGIN_SRC c
#include <unistd.h>

/* typedef int pid_t */

pid_t fork();
/* Makes a system call to trap to the OS.
 ,* This requests the OS to create a new process.
 ,* This is mostly a duplicate of the original. */
#+END_SRC

  * ~fork~ creates a copy of the current process
  * This child process is a duplicate of the parent process
    - Some metadata is different, but the binary image is the same
    - Starts with the same:
      + PC, the child starts *at the same place in the program as the parent*
      + SP
      + FP
      + Registers
      + Open Files
  * ~fork~ returns *twice*
    - Once to the parent process, with the ~pid~ of the child (>0).
    - Once to the child process, with the return code of ~fork~ (sentinel value of 0).
    - There is usually a split in the logical control flow between the parent and child.
  * ~pid_t~ is a system-wide unique process identifier
    - This is technically an integer, so we can do normal integer arithmetic

#+BEGIN_SRC c
#include <unistd.h>
#include <stdio.h>

int main(void) {
	fork();
	printf("Hello World!\n");
	return 0;
}
#+END_SRC

  * This code will print "Hello World!" twice, but in no particular order.

#+BEGIN_SRC c
#include <unistd.h>
#include <stdio.h>

int main(void) {
	fork();
	fork();
	printf("Hello World!\n");
	return 0;
}
#+END_SRC

  * This code will print "Hello World!" four time, but in no particular order.
  * The main parent thread has 2 children, and the parent's first child makes another child.

** Fork Bomb
   * Just generates new processes as fast as possible.
#+BEGIN_SRC c
#include <unistd.h>

int main() {
	while(1)
		fork();
	return 0;
}
#+END_SRC

** Using Processes
#+BEGIN_SRC c
#include <unistd.h>
#include <stdio.h>

void fork0() {
	int pid = fork();
	if (pid == 0) {
		printf("Hello from child\n");
	} else {
		printf("Hello from parent\n");
	}

	return;
}

int main(void) {
	fork0();
	return 0;
}
#+END_SRC

   * The results from this program executing is that both print statements are executed
   * But, you are not guaranteed the order in which they execute
     - Child prints first
     - Parent prints first
     - Child and parent print at the same time
     - But, there is a lock for the screen, blocking other processes
     - This lock is what makes the output text appear in order
   * The parent and child typically have some kind of logical control flow to have them do different things

** Fork Fails
   * Most system calls will return ~-1~ on a failure
   * The global variable ~errno~ is populated with the "cause" of the failure
   *

#+BEGIN_SRC c
#include <errno.h>

extern int errno;
#+END_SRC

* Terminating Processes, ~exit~
  * The simplest way to terminate a process is for the main process to ~return~
  * You can also use the ~exit~ call.
    - This exits immediately
    - This may prevent a normal ~return~
  * UNIX convention is that exit status ~0~ is success
  * Any other value is some error code

** ~atexit~
   * ~int atexit (void (*fn)());~
   * Registers a function to be used before the program is ~exit~
   * Call function before the ~exit~
   * Just have to place the registration somewhere
   * These handlers are inherited by children

** Zombie Processes
   * All processes become zombie processes eventually
   * "Dead" but tracked by the OS
     - PID remains in-use
     - Exit status can be queried.
   * Terminating/Terminated processes turn into /zombies/
     - These are just processes that have completed and exited, but the parent has not used/reaped them yet.
   * All processes are responsible for reaping their own (immediate) children
     - If a program has 2 forks, the child of the child is *not* reaped by the original parent.
   * You get rid of zombie processes by *killing* the parent processes
     - Note that this is *not* terminating the process.
   * A parent process is reaped by its starting process.
     - If a process is completely orphaned, it transfers ownership to ~PID = 1~, which will then reap it

* Problems with Multiprocessing
** Race Condition
   * Some unprotected shared memory has a flaw in its logical access
   * If we don't protect it, then the value stored is in an inconsistent state
   * Happens with /multi-threading/
     - Doesn't happen with multi-processing
     - Multi-processing makes a *full copy of memory*

* ~wait~
   * Called by a process with >= 1 children
   * Waits (if needed) for a child to terminate
     - Returns the exit status of the child
       + Termination cause
       + Normal/abnormal termination
       + Some macros defined
	 * ~WIFEXITED(status)~: Did the process exit normally?
	 * ~WEXITSTATUS(status)~:
   * Reaps a zombie child
     - If >= 1 zombified children, picks one
   * Returns the reaped child's ~PID~ and exit status via pointer (if non-~NULL~)
   * If called by a process with no children
     - Returns ~-1~ and populates ~errno~ with an error code

#+BEGIN_SRC c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>

int main() {
	pid_t cpid;
	if (fork() == 0) {
		exit(0); /* Child -> Zombie */
	}
	else {
		cpid = wait(NULL); /* Reaping Parent */
	}

	printf("Parent pid = %d\n", getpid());
	printf("Child pid  = %d\n", cpid);
	while(1);
}
#+END_SRC

** Synchronization Mechanism
   * A parent can wait for the child to finish, synchronizing things

#+BEGIN_SRC c
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>
#include <unistd.h>

void fork9() {
	if (fork() == 0) {
		printf("HC: hello from child\n");
	} else {
		printf("HP: hello form parent\n");
		wait(NULL);
		printf("CT: child has terminated\n");
	}
	printf("Child is dying. Bye\n");
}

int main() {
	fork9();
	return 0;
}
#+END_SRC


* Changing the running program, ~exec~
  * ~exec~ family of syscalls. All of these are front-ends to ~execve~.
    1) ~execl~
    2) ~execlp~
    3) ~execv~
    4) ~execvp~
  * The variations in the family:
    - ~l~: Args passed as list of strings to ~main()~
    - ~v~: Args passed as array of strings to ~main()~
    - ~p~: Path(s) to search for running program
    - ~e~: Environment (Environment variables and other state) specified by the caller
    - Each of these can be mixed to some extent.
    - Only constant between all of these is that the first argument to the ~exec...~ function is the name of the file to execute.
  * Execute a *new program* within the *current process context*
    - This doesn't give a new ~PID~
    - Replaces the binary image, in-place.
  * Complements ~fork~
  * When called, ~exec~ *never returns*
    - Starts the execution of the new program.
    - *REPLACES* the current process' running binary image

#+BEGIN_SRC c
#include <unistd.h>
#include <stdio.h>

int main() {
	execl("/bin/echo", "/bin/echo",
	      "hello", "world", (void *)0);
	/* Everything below the execl becomes unreachable code, as the new
	 ,* program REPLACES the original binary. */
	printf("Done exec-ing...\n");
	return 0;
}
#+END_SRC

Results:
#+BEGIN_SRC bash
$ ./a.out
hello world
#+END_SRC

#+BEGIN_SRC c
int main() {
	if (fork() == 0) {
		execl("/bin/ls", "/bin/ls", "-l", (void *)0);
		exit(0);
	}
	wait(NULL);
	printf("Command Completed\n");
	return 0;
}
#+END_SRC

Results:
#+BEGIN_SRC bash
$ ./a.out
-rwxr-xr-x 1 ... a.out
-rwxr-xr-x 1 ... demo.c
Command completed
#+END_SRC

