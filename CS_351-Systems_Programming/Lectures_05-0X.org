#+TITLE: Lectures 05-0X, A C Primer
#+AUTHOR: Karl Hallsby
#+DATE: September 09, 2020

* Man Pages
Manual pages included in the GNU/Linux operating systems.

Accessed with =man= command.

* C
  * Imperative
    - Finite-state based computation/machines
    - In contrast to Functional Languages
  * Statically Typed
    - When something is declared to be a certain type, it stays that way
    - Have to deal with type polymorphism
    - Have to perform type checking during compilation
  * Weakly Type Checked
    - You are not guaranteed that when you access data that you are interpreting the bytes the right way.
    - You can typecast pointers and do weird things.
    - Compiler might not throw type-checking errors
  * Procedural
    - You can organize repeated computation into functions/procedures
  * "Low-Level"
    - As close as possible to hardware, without writing assembly

** C vs. Java
| C                                                     | Java                                                    |
|-------------------------------------------------------+---------------------------------------------------------|
| Procedural                                            | Object-oriented                                         |
| Source-level portability (Need to recompile)          | Compiled-code portability (Can just move binary around) |
| Manual Memory management (You must deallocate memory) | Garbage collected (Runtime system deallocates memory)   |
| Pointers reference addresses                          | Opaque memory references                                |
| Manual error checking                                 | Exception handling                                      |
| Manual namespace partitioning                         | Namespaces with packages                                |
| Small, low-level libraries                            | Vast, high-level class libraries                        |

** Philosophies
*** C
"Make it efficient and simple, and let the programmer do whatever they want..."

*** Java
"Make it portable, provide a huge class library, and try to protect the programmer from doing stupid things.

** ANSI C
   * American National Standards Institute
   * These standards allow for cross-compilation.
   * Current ANSI C11

* C11
  * Language Syntax
  * Language Semantics
  * Runtime Features/Behavior
    - Type info
    - Memory Model
  * Limited Standard Library API

It leaves *OUT* many "core" libraries.

* Syntax and Structure
** Primitive Types
   * =char= - *One byte* integers (0-255)
   * =int= - Integer, /at least/ 16 bits
   * =float= Single precision floating point
   * =double= Double precision floating point

** Integer Type Prefixes
   * =signed= (default)
   * =unsigned=, 0-2^(# bits)
   * =short= at least 16 bits
   * =long= at least 32 bits
   * =long long= at least 64 bits

** C's Weak Typechecking
#+BEGIN_SRC c
/* Types are implicitly converted */
char c = 0x41424344;
int i = 1.5;
unsigned in t u = -1;
float f = 10;
double d = 2.5F; // Note: 'F' suffix for floating point literals

printf("c = '%c', i = %d, u = %u, f = %f, d = %f\n", c, i, u, f, d);

/* Typecasts can be used to force conversions */
int r1 = f/d,
	r2 = f / (int) d;

printf("r1 = %d, r2 = %d\n", r1, r2);
#+END_SRC
c = 'D', i = 1, u = 4294967295, f =10.00000

** Basic Operators
   * Arithmetic:
     - =+=
     - =-=
     - =*=
     - =&=, Bitwise AND
     - =|=, Bitwise OR
     - =~=, Bitwise negation
   * Relational
   * Logical
   * Assignment
     - ===
     - =+==
     - =*==
   * Conditional
     - =bool ? true_exp : false_exp=

** Booleans
   * =0= is False
   * Everything else is considered true
     - Canonically =1= is true

#+BEGIN_SRC c
!(0)         // 1
0 || 2       // 1
3 && 0 && 6  // 0
!(1234)      // 0
!!(-1020)    //1
#+END_SRC

** Control Structure
   * if-else
   * switch-case
   * while, for, do-while
     - =continue=
     - =break=

** Variables
   * *MUST* be _declared_ before use.
   * This declaration implicitly *allocates* storage for the underlying data.
   * Variables can be declared with =global= for program-wide usage.
   * Variables do *not* have to be visible to be alive, and vice versa.

*** Visibility
    * /Where/ a symbol can be seen from.
      - If it cannot be seen, then it cannot be used in any way
    * /How/ can we refer to it?
      - What identifiers/modifiers/namespacing is needed to identify this symbol?
    * ~global~ variables must be declared outside any function.
      - Not deallocated *throughout* a program's execution.
      - Always available until the program terminates.
    * Local variables are defined within a function.
      - The [[*Lifetime][Lifetime]] of a stack-based local variable is the scope of the variable
      - Typically, the scope is a function, but can be an ~if~, a ~while~, etc.
    * ~extern~ on a variable tells the compiler to look for the global variable that is in another file
      - Use this if the global variable is *Declared and Defined* in a ~.c~ file, and cannot be defined in a ~.h~ file.
      - This also allows you to separate the *declaration* and *definition* of a variable
    * ~static~ limits the visibility of a symbol to its file.

*** Lifetime
    * /How Long/ does allocated storage space remain usable?
    * This is distinctly different than a symbol not being visible.
      - Pointers are a good example of this.
      - A pointer can have the memory underneath it deallocated, ending the lifetime of the pointer, but keeping the pointer in-scope.
    * ~static~ initializes the variable in the static portion of the binary, meaning it is *always* alive.

** Functions
   * C's /top-level/ modules

*** Declaration
    * Announce that a function with those input and output parameters
    * Included in /header/ =.h= files

*** Passing Parameters
**** Pass-by-Value
     * Make a copy of the value passed to a function and give it a new name
     * This is a *COPY*, meaning modifications to the copy *DO NOT* affect the original

**** Pass-by-Reference
     * Pass a pointer into the called function
     * This gives the called function access to the thing given to it.
     * This allows for efficient passing of data from one function to another.
     * This is particularly valuable for large ~struct~, arrays, etc.

*** Definition
    * The actual implementation
    * Inside /source/ =.c= files.

=hashtable.h=
#+BEGIN_SRC c
unsigned long hash(char *str);
hashtable_t *make_hashtable(unsigned long size);
void ht_put(hashtable_t *ht, char *key, void *val);
#+END_SRC

=hashtable.c=
#+BEGIN_SRC c
#include "hashtable.h"

unsigned long hash(char *str) {
	unsigned long hash = 5381;
	int c;
	while ((c = *str++))
		hash = ((hash << 5) + hash) + c;
	return 0;
}
#+END_SRC

=main.c=
#+BEGIN_SRC c
#include "hashtable.h"

int main(int argc, char *argv[]) {
	hashtable_t *ht;
	ht = make_hashtable(atoi(argv[1]));
	return 0;
}
#+END_SRC

* Pointers
This should technically go in [[*Syntax and Structure][Syntax and Structure]], but pointers deserve their own section.

A /pointer/ is a variable declared to store a memory address
A /memory address/ is the address to which we can refer to data in-memory.
The size of the pointer is determined by the architecture of the CPU.

A pointer is designated by its *declared* type, not its contents.
This allows the pointer's contents to be re-interpreted based on the type of the pointer.

** Pointer Syntax
#+BEGIN_SRC c
#include <stdio.h>

int main(void) {
	int i, j, *p, *q;

	i = 10;       /* i is defined to have the value 10 */
	p = &j;       /* j is uninitialized still */
	q = p;        /* Set the pointer q to the address in p */
	,*q = i;      /* Store i in the location q POINTS to, which is j right now */
	,*p = *q * 2; /* Multply the value q POINTS to by 2 and store in the location POINTED to by p */
	printf("i=%d, j=%d, *p=%d, *q=%d\n", i, j, *p, *q);
	return 0;
}
#+END_SRC

This outputs: "~i=10, j=20, *p=20, *q=20~"

*** Declaration
#+BEGIN_SRC c
/* type *var_name; */
int *ip;
char *cp;
struct student *sp;

int i = 5; /* i is an int containing 5 */
int *p;    /* p is a POINTER to an int */

p = &i;    /* Store the ADDRESS of i in p */

int j;     /* j is an uninitialized int */
j = *p;    /* store the value p POINTS to in j */
#+END_SRC

*** Getting an Address
You can get the address of a name with ~&~.

*** Dereferencing
~*~ is *also* used to *dereference* the pointer!

* Compilation
  * You can manually compile every =.c= file with =gcc=
  * This can be very painful for larger projects
  * We use makefiles to manage this.

** Stages
   1) Preprocessing
      * Preprocessor /directives/
      * Text substitution
      * Macros
      * Conditional compilation
      * Directives starting with =#=
      * Performs complete textual substitution behind the scenes
   2) Compile
      * From source language to object code/binary
   3) Link
      * Put inter-related object codes together
      * Resolve calls/references and definitions
      * Put absolute/relative addresses into the binary for the =call= instruction
      * Want to support /selective/ public APIs
      * Don't always want to allow linking a call to a definition
   4)

** Makefiles
   * Allow for:
     - Incremental compilation
     - Automated compilation
