#+TITLE: Lectures 05, A C Primer
#+AUTHOR: Karl Hallsby
#+DATE: September 09, 2020

* Man Pages
Manual pages included in the GNU/Linux operating systems.

Accessed with =man= command.

* C
  * Imperative
    - Finite-state based computation/machines
    - In contrast to Functional Languages
  * Statically Typed
    - When something is declared to be a certain type, it stays that way
    - Have to deal with type polymorphism
    - Have to perform type checking during compilation
  * Weakly Type Checked
    - You are not guaranteed that when you access data that you are interpreting the bytes the right way.
    - You can typecast pointers and do weird things.
    - Compiler might not throw type-checking errors
  * Procedural
    - You can organize repeated computation into functions/procedures
  * "Low-Level"
    - As close as possible to hardware, without writing assembly

** C vs. Java
| C                                                     | Java                                                    |
|-------------------------------------------------------+---------------------------------------------------------|
| Procedural                                            | Object-oriented                                         |
| Source-level portability (Need to recompile)          | Compiled-code portability (Can just move binary around) |
| Manual Memory management (You must deallocate memory) | Garbage collected (Runtime system deallocates memory)   |
| Pointers reference addresses                          | Opaque memory references                                |
| Manual error checking                                 | Exception handling                                      |
| Manual namespace partitioning                         | Namespaces with packages                                |
| Small, low-level libraries                            | Vast, high-level class libraries                        |

** Philosophies
*** C
"Make it efficient and simple, and let the programmer do whatever they want..."

*** Java
"Make it portable, provide a huge class library, and try to protect the programmer from doing stupid things.

** ANSI C
   * American National Standards Institute
   * These standards allow for cross-compilation.
   * Current ANSI C11

* C11
  * Language Syntax
  * Language Semantics
  * Runtime Features/Behavior
    - Type info
    - Memory Model
  * Limited Standard Library API

It leaves *OUT* many "core" libraries.

* Syntax and Structure
** Primitive Types
   * =char= - *One byte* integers (0-255)
   * =int= - Integer, /at least/ 16 bits
   * =float= Single precision floating point
   * =double= Double precision floating point

** Integer Type Prefixes
   * =signed= (default)
   * =unsigned=, 0-2^(# bits)
   * =short= at least 16 bits
   * =long= at least 32 bits
   * =long long= at least 64 bits

** C's Weak Typechecking
#+BEGIN_SRC c
/* Types are implicitly converted */
char c = 0x41424344;
int i = 1.5;
unsigned in t u = -1;
float f = 10;
double d = 2.5F; // Note: 'F' suffix for floating point literals

printf("c = '%c', i = %d, u = %u, f = %f, d = %f\n", c, i, u, f, d);

/* Typecasts can be used to force conversions */
int r1 = f/d,
	r2 = f / (int) d;

printf("r1 = %d, r2 = %d\n", r1, r2);
#+END_SRC
c = 'D', i = 1, u = 4294967295, f =10.00000

** Basic Operators
   * Arithmetic:
     - =+=
     - =-=
     - =*=
     - =&=, Bitwise AND
     - =|=, Bitwise OR
     - =~=, Bitwise negation
   * Relational
   * Logical
   * Assignment
     - ===
     - =+==
     - =*==
   * Conditional
     - =bool ? true_exp : false_exp=

** Booleans
   * =0= is False
   * Everything else is considered true
     - Canonically =1= is true

#+BEGIN_SRC c
!(0)         // 1
0 || 2       // 1
3 && 0 && 6  // 0
!(1234)      // 0
!!(-1020)    //1
#+END_SRC

** Control Structure
   * if-else
   * switch-case
   * while, for, do-while
     - =continue=
     - =break=

** Variables
   * *MUST* be _declared_ before use.
   * This declaration implicitly *allocates* storage for the underlying data.
   * Variables can be declared with =global= for program-wide usage.

** Functions
   * C's /top-level/ modules

*** Declaration
    * Announce that a function with those input and output parameters
    * Included in /header/ =.h= files

*** Definition
    * The actual implementation
    * Inside /source/ =.c= files.

=hashtable.h=
#+BEGIN_SRC c
unsigned long hash(char *str);
hashtable_t *make_hashtable(unsigned long size);
void ht_put(hashtable_t *ht, char *key, void *val);
#+END_SRC

=hashtable.c=
#+BEGIN_SRC c
#include "hashtable.h"

unsigned long hash(char *str) {
	unsigned long hash = 5381;
	int c;
	while ((c = *str++))
		hash = ((hash << 5) + hash) + c;
	return 0;
}
#+END_SRC

=main.c=
#+BEGIN_SRC c
#include "hashtable.h"

int main(int argc, char *argv[]) {
	hashtable_t *ht;
	ht = make_hashtable(atoi(argv[1]));
	return 0;
}
#+END_SRC

* Compilation
  * You can manually compile every =.c= file with =gcc=
  * This can be very painful for larger projects
  * We use makefiles to manage this.

** Stages
   1) Preprocessing
      * Preprocessor /directives/
      * Text substitution
      * Macros
      * Conditional compilation
      * Directives starting with =#=
      * Performs complete textual substitution behind the scenes
   2) Compile
      * From source language to object code/binary
   3) Link
      * Put inter-related object codes together
      * Resolve calls/references and definitions
      * Put absolute/relative addresses into the binary for the =call= instruction
      * Want to support /selective/ public APIs
      * Don't always want to allow linking a call to a definition
   4)

** Makefiles
   * Allow for:
     - Incremental compilation
     - Automated compilation
